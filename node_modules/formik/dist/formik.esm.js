import { __assign, __rest, __extends } from 'tslib';
import { Children, createContext, useContext, useRef, useReducer, useCallback, useEffect, useMemo, createElement, Component } from 'react';
import isEqual from 'react-fast-compare';
import deepmerge from 'deepmerge';
import cloneDeep from 'lodash-es/cloneDeep';
import toPath from 'lodash-es/toPath';
import warning from 'tiny-warning';
import hoistNonReactStatics from 'hoist-non-react-statics';

function getIn(obj, key, def, p) {
  if (p === void 0) {
    p = 0;
  }

  var path = toPath(key);

  while (obj && p < path.length) {
    obj = obj[path[p++]];
  }

  return obj === undefined ? def : obj;
}
function setIn(obj, path, value) {
  var res = {};
  var resVal = res;
  var i = 0;
  var pathArray = toPath(path);

  for (; i < pathArray.length - 1; i++) {
    var currentPath = pathArray[i];
    var currentObj = getIn(obj, pathArray.slice(0, i + 1));

    if (resVal[currentPath]) {
      resVal = resVal[currentPath];
    } else if (currentObj) {
      resVal = resVal[currentPath] = cloneDeep(currentObj);
    } else {
      var nextPath = pathArray[i + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }

  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
    return obj;
  }

  if (value === undefined) {
    delete resVal[pathArray[i]];
  } else {
    resVal[pathArray[i]] = value;
  }

  var result = __assign({}, obj, res);

  if (i === 0 && value === undefined) {
    delete result[pathArray[i]];
  }

  return result;
}
function setNestedObjectValues(object, value, visited, response) {
  if (visited === void 0) {
    visited = new WeakMap();
  }

  if (response === void 0) {
    response = {};
  }

  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
    var k = _a[_i];
    var val = object[k];

    if (isObject(val)) {
      if (!visited.get(val)) {
        visited.set(val, true);
        response[k] = Array.isArray(val) ? [] : {};
        setNestedObjectValues(val, value, visited, response[k]);
      }
    } else {
      response[k] = value;
    }
  }

  return response;
}
var isFunction = function (obj) {
  return typeof obj === 'function';
};
var isObject = function (obj) {
  return obj !== null && typeof obj === 'object';
};
var isInteger = function (obj) {
  return String(Math.floor(Number(obj))) === obj;
};
var isString = function (obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
};
var isNaN$1 = function (obj) {
  return obj !== obj;
};
var isEmptyChildren = function (children) {
  return Children.count(children) === 0;
};
var isPromise = function (value) {
  return isObject(value) && isFunction(value.then);
};
function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);

  if (typeof doc === 'undefined') {
    return null;
  }

  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
function makeCancelable(promise) {
  var hasCanceled = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function (val) {
      return hasCanceled ? reject({
        isCanceled: true
      }) : resolve(val);
    }, function (error) {
      return hasCanceled ? reject({
        isCanceled: true
      }) : reject(error);
    });
  });
  return [wrappedPromise, function cancel() {
    hasCanceled = true;
  }];
}

var PrivateFormikContext =
/*#__PURE__*/
createContext({});
var FormikProvider = PrivateFormikContext.Provider;
var FormikConsumer = PrivateFormikContext.Consumer;
function useFormikContext() {
  return useContext(PrivateFormikContext);
}

function formikReducer(state, msg) {
  switch (msg.type) {
    case 'SET_VALUES':
      return __assign({}, state, {
        values: msg.payload
      });

    case 'SET_TOUCHED':
      return __assign({}, state, {
        touched: msg.payload
      });

    case 'SET_ERRORS':
      return __assign({}, state, {
        errors: msg.payload
      });

    case 'SET_STATUS':
      return __assign({}, state, {
        status: msg.payload
      });

    case 'SET_ISSUBMITTING':
      return __assign({}, state, {
        isSubmitting: msg.payload
      });

    case 'SET_ISVALIDATING':
      return __assign({}, state, {
        isValidating: msg.payload
      });

    case 'SET_FIELD_VALUE':
      return __assign({}, state, {
        values: setIn(state.values, msg.payload.field, msg.payload.value)
      });

    case 'SET_FIELD_TOUCHED':
      return __assign({}, state, {
        touched: setIn(state.touched, msg.payload.field, msg.payload.value)
      });

    case 'SET_FIELD_ERROR':
      return __assign({}, state, {
        errors: setIn(state.errors, msg.payload.field, msg.payload.value)
      });

    case 'RESET_FORM':
    case 'SET_FORMIK_STATE':
      return __assign({}, state, msg.payload);

    case 'SUBMIT_ATTEMPT':
      return __assign({}, state, {
        touched: setNestedObjectValues(state.values, true),
        isSubmitting: true,
        submitCount: state.submitCount + 1
      });

    case 'SUBMIT_FAILURE':
      return __assign({}, state, {
        isSubmitting: false
      });

    case 'SUBMIT_SUCCESS':
      return __assign({}, state, {
        isSubmitting: false
      });

    default:
      return state;
  }
}

function useFormik(_a) {
  var _b = _a.validateOnChange,
      validateOnChange = _b === void 0 ? true : _b,
      _c = _a.validateOnBlur,
      validateOnBlur = _c === void 0 ? true : _c,
      _d = _a.isInitialValid,
      isInitialValid = _d === void 0 ? false : _d,
      rest = __rest(_a, ["validateOnChange", "validateOnBlur", "isInitialValid"]);

  var props = __assign({
    validateOnChange: validateOnChange,
    validateOnBlur: validateOnBlur,
    isInitialValid: isInitialValid
  }, rest);

  var initialValues = useRef(props.initialValues);
  var isMounted = useRef(false);
  var fields = useRef({});

  var _e = useReducer(formikReducer, {
    values: props.initialValues,
    errors: {},
    touched: {},
    isSubmitting: false,
    isValidating: false,
    submitCount: 0
  }),
      state = _e[0],
      dispatch = _e[1];

  var runValidationAsEffect = useCallback(function () {
    var _a = makeCancelable(validateForm(state.values)),
        validate = _a[0],
        cancel = _a[1];

    validate.then(function (x) {
      return x;
    }).catch(function (x) {
      return x;
    });
    return cancel;
  }, [state.values]);
  useEffect(function () {
    if (!!validateOnChange && !state.isSubmitting && isMounted.current) {
      return runValidationAsEffect();
    }

    return;
  }, [state.values]);
  useEffect(function () {
    if (!!validateOnBlur && !state.isSubmitting && isMounted.current) {
      return runValidationAsEffect();
    }

    return;
  }, [state.touched]);
  useEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  var imperativeMethods = {
    resetForm: resetForm,
    submitForm: submitForm,
    validateForm: validateForm,
    validateField: validateField,
    setErrors: setErrors,
    setFieldError: setFieldError,
    setFieldTouched: setFieldTouched,
    setFieldValue: setFieldValue,
    setStatus: setStatus,
    setSubmitting: setSubmitting,
    setTouched: setTouched,
    setValues: setValues,
    setFormikState: setFormikState
  };

  function registerField(name, _a) {
    var validate = _a.validate;

    if (fields.current !== null) {
      fields.current[name] = {
        validate: validate
      };
    }
  }

  function unregisterField(name) {
    if (fields.current !== null) {
      delete fields.current[name];
    }
  }

  function handleBlur(eventOrString) {
    if (isString(eventOrString)) {
      return function (event) {
        return executeBlur(event, eventOrString);
      };
    } else {
      executeBlur(eventOrString);
    }

    function executeBlur(e, path) {
      if (e.persist) {
        e.persist();
      }

      var _a = e.target,
          name = _a.name,
          id = _a.id,
          outerHTML = _a.outerHTML;
      var field = path ? path : name ? name : id;

      if (!field && process.env.NODE_ENV !== 'production') {
        warnAboutMissingIdentifier({
          htmlContent: outerHTML,
          documentationAnchorLink: 'handleblur-e-any--void',
          handlerName: 'handleBlur'
        });
      }

      dispatch({
        type: 'SET_FIELD_TOUCHED',
        payload: {
          field: field,
          value: true
        }
      });
    }
  }

  function handleChange(eventOrPath) {
    if (isString(eventOrPath)) {
      return function (event) {
        return executeChange(event, eventOrPath);
      };
    } else {
      executeChange(eventOrPath);
    }

    function executeChange(eventOrTextValue, maybePath) {
      var field = maybePath;
      var val = eventOrTextValue;
      var parsed;

      if (!isString(eventOrTextValue)) {
        if (eventOrTextValue.persist) {
          eventOrTextValue.persist();
        }

        var _a = eventOrTextValue.target,
            type = _a.type,
            name_1 = _a.name,
            id = _a.id,
            value = _a.value,
            checked = _a.checked,
            outerHTML = _a.outerHTML;
        field = maybePath ? maybePath : name_1 ? name_1 : id;

        if (!field && process.env.NODE_ENV !== 'production') {
          warnAboutMissingIdentifier({
            htmlContent: outerHTML,
            documentationAnchorLink: 'handlechange-e-reactchangeeventany--void',
            handlerName: 'handleChange'
          });
        }

        val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? '' : parsed) : /checkbox/.test(type) ? checked : value;
      }

      if (field) {
        dispatch({
          type: 'SET_FIELD_VALUE',
          payload: {
            field: field,
            value: val
          }
        });
      }
    }
  }

  function handleReset() {
    if (props.onReset) {
      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);

      if (isPromise(maybePromisedOnReset)) {
        maybePromisedOnReset.then(resetForm);
      } else {
        resetForm();
      }
    } else {
      resetForm();
    }
  }

  function handleSubmit(e) {
    if (e && e.preventDefault) {
      e.preventDefault();
    }

    if (process.env.NODE_ENV !== 'production' && typeof document !== 'undefined') {
      var activeElement = getActiveElement();

      if (activeElement !== null && activeElement instanceof HTMLButtonElement) {
        process.env.NODE_ENV !== "production" ? warning(activeElement.attributes && activeElement.attributes.getNamedItem('type'), 'You submitted a Formik form using a button with an unspecified `type` attribute.  Most browsers default button elements to `type="submit"`. If this is not a submit button, please add `type="button"`.') : void 0;
      }
    }

    submitForm();
  }

  function executeSubmit() {
    return props.onSubmit(state.values, imperativeMethods);
  }

  function resetForm(nextValues) {
    var values = nextValues ? nextValues : initialValues.current !== null ? initialValues.current : props.initialValues;
    initialValues.current = values;
    dispatch({
      type: 'RESET_FORM',
      payload: {
        isSubmitting: false,
        errors: {},
        touched: {},
        status: undefined,
        values: values,
        isValidating: false,
        submitCount: 0
      }
    });
  }

  function setTouched(touched) {
    dispatch({
      type: 'SET_TOUCHED',
      payload: touched
    });
  }

  function setErrors(errors) {
    dispatch({
      type: 'SET_ERRORS',
      payload: errors
    });
  }

  function setValues(values) {
    dispatch({
      type: 'SET_VALUES',
      payload: values
    });
  }

  function setFieldError(field, value) {
    dispatch({
      type: 'SET_FIELD_ERROR',
      payload: {
        field: field,
        value: value
      }
    });
  }

  function setFieldValue(field, value) {
    dispatch({
      type: 'SET_FIELD_VALUE',
      payload: {
        field: field,
        value: value
      }
    });
  }

  function setFieldTouched(field, touched) {
    if (touched === void 0) {
      touched = true;
    }

    dispatch({
      type: 'SET_FIELD_TOUCHED',
      payload: {
        field: field,
        value: touched
      }
    });
  }

  function validateField(name) {
    if (fields.current !== null && fields.current[name] && fields.current[name].validate && isFunction(fields.current[name].validate)) {
      var value = getIn(state.values, name);
      var maybePromise = fields.current[name].validate(value);

      if (isPromise(maybePromise)) {
        dispatch({
          type: 'SET_ISVALIDATING',
          payload: true
        });
        return maybePromise.then(function (x) {
          return x;
        }, function (e) {
          return e;
        }).then(function (error) {
          dispatch({
            type: 'SET_FIELD_ERROR',
            payload: {
              field: name,
              value: error
            }
          });
          dispatch({
            type: 'SET_ISVALIDATING',
            payload: false
          });
        });
      } else {
        dispatch({
          type: 'SET_FIELD_ERROR',
          payload: {
            field: name,
            value: maybePromise
          }
        });
        return Promise.resolve(maybePromise);
      }
    } else {
      return Promise.resolve();
    }
  }

  function runValidateHandler(values, field) {
    return new Promise(function (resolve) {
      var maybePromisedErrors = props.validate(values, field);

      if (maybePromisedErrors === undefined) {
        resolve({});
      } else if (isPromise(maybePromisedErrors)) {
        maybePromisedErrors.then(function () {
          resolve({});
        }, function (errors) {
          resolve(errors);
        });
      } else {
        resolve(maybePromisedErrors);
      }
    });
  }

  function runValidationSchema(values, field) {
    return new Promise(function (resolve) {
      var validationSchema = props.validationSchema;
      var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;
      var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);
      promise.then(function () {
        resolve({});
      }, function (err) {
        resolve(yupToFormErrors(err));
      });
    });
  }

  function runSingleFieldLevelValidation(field, value) {
    return new Promise(function (resolve) {
      return resolve(fields.current[field].validate(value));
    }).then(function (x) {
      return x;
    }, function (e) {
      return e;
    });
  }

  function runFieldLevelValidations(values) {
    if (fields.current === null) {
      return Promise.resolve({});
    }

    var fieldKeysWithValidation = Object.keys(fields.current).filter(function (f) {
      return fields.current !== null && fields.current[f] && fields.current[f].validate && isFunction(fields.current[f].validate);
    });
    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function (f) {
      return runSingleFieldLevelValidation(f, getIn(values, f));
    }) : [Promise.resolve('DO_NOT_DELETE_YOU_WILL_BE_FIRED')];
    return Promise.all(fieldValidations).then(function (fieldErrorsList) {
      return fieldErrorsList.reduce(function (prev, curr, index) {
        if (curr === 'DO_NOT_DELETE_YOU_WILL_BE_FIRED') {
          return prev;
        }

        if (!!curr) {
          prev = setIn(prev, fieldKeysWithValidation[index], curr);
        }

        return prev;
      }, {});
    });
  }

  function validateForm(values) {
    if (values === void 0) {
      values = state.values;
    }

    if (props.validationSchema || props.validate || fields.current && Object.keys(fields.current).filter(function (key) {
      return !!fields.current[key].validate;
    }).length > 0) {
      dispatch({
        type: 'SET_ISVALIDATING',
        payload: true
      });
      return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function (_a) {
        var fieldErrors = _a[0],
            schemaErrors = _a[1],
            validateErrors = _a[2];
        var combinedErrors = deepmerge.all([fieldErrors, schemaErrors, validateErrors], {
          arrayMerge: arrayMerge
        });

        if (!isEqual(state.errors, combinedErrors)) {
          dispatch({
            type: 'SET_ERRORS',
            payload: combinedErrors
          });
        }

        dispatch({
          type: 'SET_ISVALIDATING',
          payload: false
        });
        return combinedErrors;
      });
    } else {
      return Promise.resolve({});
    }
  }

  function setFormikState(stateOrCb) {
    if (isFunction(stateOrCb)) {
      dispatch({
        type: 'SET_FORMIK_STATE',
        payload: stateOrCb(state)
      });
    } else {
      dispatch({
        type: 'SET_FORMIK_STATE',
        payload: stateOrCb
      });
    }
  }

  function setStatus(status) {
    dispatch({
      type: 'SET_STATUS',
      payload: status
    });
  }

  function setSubmitting(isSubmitting) {
    dispatch({
      type: 'SET_ISSUBMITTING',
      payload: isSubmitting
    });
  }

  function submitForm() {
    dispatch({
      type: 'SUBMIT_ATTEMPT'
    });
    return validateForm().then(function (combinedErrors) {
      var isActuallyValid = Object.keys(combinedErrors).length === 0;

      if (isActuallyValid) {
        Promise.resolve(executeSubmit()).then(function () {
          if (isMounted.current) {
            dispatch({
              type: 'SUBMIT_SUCCESS'
            });
          }
        }).catch(function (_errors) {
          if (isMounted.current) {
            dispatch({
              type: 'SUBMIT_FAILURE'
            });
          }
        });
      } else if (isMounted.current) {
        dispatch({
          type: 'SUBMIT_FAILURE'
        });
      }
    });
  }

  function getFieldProps(name, type) {
    var field = {
      name: name,
      value: type && (type === 'radio' || type === 'checkbox') ? undefined : getIn(state.values, name),
      onChange: handleChange,
      onBlur: handleBlur
    };
    return [field, getFieldMeta(name)];
  }

  function getFieldMeta(name) {
    return {
      value: getIn(state.values, name),
      error: getIn(state.errors, name),
      touch: getIn(state.touched, name),
      initialValue: getIn(initialValues.current, name)
    };
  }

  var dirty = useMemo(function () {
    return !isEqual(initialValues.current, state.values);
  }, [initialValues.current, state.values]);
  var isValid = useMemo(function () {
    return dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid;
  }, [state.errors, dirty, isInitialValid]);

  var ctx = __assign({}, state, {
    initialValues: initialValues.current || props.initialValues,
    handleBlur: handleBlur,
    handleChange: handleChange,
    handleReset: handleReset,
    handleSubmit: handleSubmit,
    resetForm: resetForm,
    setErrors: setErrors,
    setFormikState: setFormikState,
    setFieldTouched: setFieldTouched,
    setFieldValue: setFieldValue,
    setFieldError: setFieldError,
    setStatus: setStatus,
    setSubmitting: setSubmitting,
    setTouched: setTouched,
    setValues: setValues,
    submitForm: submitForm,
    validateForm: validateForm,
    validateField: validateField,
    isValid: isValid,
    dirty: dirty,
    unregisterField: unregisterField,
    registerField: registerField,
    getFieldProps: getFieldProps,
    validateOnBlur: validateOnBlur,
    validateOnChange: validateOnChange
  });

  return ctx;
}
function Formik(props) {
  var formikbag = useFormik(props);
  var component = props.component,
      children = props.children,
      render = props.render;
  return createElement(FormikProvider, {
    value: formikbag
  }, component ? createElement(component, formikbag) : render ? render(formikbag) : children ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? Children.only(children) : null : null);
}

function warnAboutMissingIdentifier(_a) {
  var htmlContent = _a.htmlContent,
      documentationAnchorLink = _a.documentationAnchorLink,
      handlerName = _a.handlerName;
  console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + htmlContent + "\n    Formik cannot determine which value to update. For more info see https://github.com/jaredpalmer/formik#" + documentationAnchorLink + "\n  ");
}

function yupToFormErrors(yupError) {
  var errors = {};

  if (yupError.inner.length === 0) {
    return setIn(errors, yupError.path, yupError.message);
  }

  for (var _i = 0, _a = yupError.inner; _i < _a.length; _i++) {
    var err = _a[_i];

    if (!errors[err.path]) {
      errors = setIn(errors, err.path, err.message);
    }
  }

  return errors;
}
function validateYupSchema(values, schema, sync, context) {
  if (sync === void 0) {
    sync = false;
  }

  if (context === void 0) {
    context = {};
  }

  var validateData = {};

  for (var k in values) {
    if (values.hasOwnProperty(k)) {
      var key = String(k);
      validateData[key] = values[key] !== '' ? values[key] : undefined;
    }
  }

  return schema[sync ? 'validateSync' : 'validate'](validateData, {
    abortEarly: false,
    context: context
  });
}

function arrayMerge(target, source, options) {
  var destination = target.slice();
  source.forEach(function (e, i) {
    if (typeof destination[i] === 'undefined') {
      var cloneRequested = options.clone !== false;
      var shouldClone = cloneRequested && options.isMergeableObject(e);
      destination[i] = shouldClone ? deepmerge(Array.isArray(e) ? [] : {}, e, options) : e;
    } else if (options.isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, options);
    } else if (target.indexOf(e) === -1) {
      destination.push(e);
    }
  });
  return destination;
}

function useField(name, type) {
  var formik = useFormikContext();

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== "production" ? warning(formik, 'useField() / <Field /> must be used underneath a <Formik> component or withFormik() higher order component') : void 0;
  }

  return formik.getFieldProps(name, type);
}
function Field(_a) {
  var validate = _a.validate,
      name = _a.name,
      render = _a.render,
      children = _a.children,
      _b = _a.component,
      component = _b === void 0 ? 'input' : _b,
      props = __rest(_a, ["validate", "name", "render", "children", "component"]);

  var _c = useFormikContext(),
      _validate = _c.validate,
      _validationSchema = _c.validationSchema,
      formik = __rest(_c, ["validate", "validationSchema"]);

  process.env.NODE_ENV !== "production" ? warning(component && render, 'You should not use <Field component> and <Field render> in the same <Field> component; <Field component> will be ignored') : void 0;
  process.env.NODE_ENV !== "production" ? warning(component && children && isFunction(children), 'You should not use <Field component> and <Field children> as a function in the same <Field> component; <Field component> will be ignored.') : void 0;
  process.env.NODE_ENV !== "production" ? warning(render && children && !isEmptyChildren(children), 'You should not use <Field render> and <Field children> in the same <Field> component; <Field children> will be ignored') : void 0;
  useEffect(function () {
    formik.registerField(name, {
      validate: validate
    });
    return function () {
      formik.unregisterField(name);
    };
  }, [name, validate]);
  var field = formik.getFieldProps(name, props.type)[0];
  var bag = {
    field: field,
    form: formik
  };

  if (render) {
    return render(bag);
  }

  if (isFunction(children)) {
    return children(bag);
  }

  if (typeof component === 'string') {
    var innerRef = props.innerRef,
        rest = __rest(props, ["innerRef"]);

    return createElement(component, __assign({
      ref: innerRef
    }, field, rest, {
      children: children
    }));
  }

  return createElement(component, __assign({}, bag, props, {
    children: children
  }));
}
var FastField = Field;

function Form(props) {
  var _a = useFormikContext(),
      handleReset = _a.handleReset,
      handleSubmit = _a.handleSubmit;

  return createElement("form", __assign({
    onSubmit: handleSubmit,
    onReset: handleReset
  }, props));
}
Form.displayName = 'Form';

function withFormik(_a) {
  var _b = _a.mapPropsToValues,
      mapPropsToValues = _b === void 0 ? function (vanillaProps) {
    var val = {};

    for (var k in vanillaProps) {
      if (vanillaProps.hasOwnProperty(k) && typeof vanillaProps[k] !== 'function') {
        val[k] = vanillaProps[k];
      }
    }

    return val;
  } : _b,
      config = __rest(_a, ["mapPropsToValues"]);

  return function createFormik(Component$$1) {
    var componentDisplayName = Component$$1.displayName || Component$$1.name || Component$$1.constructor && Component$$1.constructor.name || 'Component';

    var C = function (_super) {
      __extends(C, _super);

      function C() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.validate = function (values) {
          return config.validate(values, _this.props);
        };

        _this.validationSchema = function () {
          return isFunction(config.validationSchema) ? config.validationSchema(_this.props) : config.validationSchema;
        };

        _this.handleSubmit = function (values, actions) {
          return config.handleSubmit(values, __assign({}, actions, {
            props: _this.props
          }));
        };

        _this.renderFormComponent = function (formikProps) {
          return createElement(Component$$1, __assign({}, _this.props, formikProps));
        };

        return _this;
      }

      C.prototype.render = function () {
        var _a = this.props,
            children = _a.children,
            props = __rest(_a, ["children"]);

        return createElement(Formik, __assign({}, props, config, {
          validate: config.validate && this.validate,
          validationSchema: config.validationSchema && this.validationSchema,
          initialValues: mapPropsToValues(this.props),
          initialStatus: config.mapPropsToStatus && config.mapPropsToStatus(this.props),
          onSubmit: this.handleSubmit,
          render: this.renderFormComponent
        }));
      };

      C.displayName = "WithFormik(" + componentDisplayName + ")";
      return C;
    }(Component);

    return hoistNonReactStatics(C, Component$$1);
  };
}

function connect(Comp) {
  var C = function (props) {
    return createElement(FormikConsumer, null, function (formik) {
      return createElement(Comp, __assign({}, props, {
        formik: formik
      }));
    });
  };

  var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || 'Component';
  C.WrappedComponent = Comp;
  C.displayName = "FormikConnect(" + componentDisplayName + ")";
  return hoistNonReactStatics(C, Comp);
}

var move = function (array, from, to) {
  var copy = (array || []).slice();
  var value = copy[from];
  copy.splice(from, 1);
  copy.splice(to, 0, value);
  return copy;
};
var swap = function (array, indexA, indexB) {
  var copy = (array || []).slice();
  var a = copy[indexA];
  copy[indexA] = copy[indexB];
  copy[indexB] = a;
  return copy;
};
var insert = function (array, index, value) {
  var copy = (array || []).slice();
  copy.splice(index, 0, value);
  return copy;
};
var replace = function (array, index, value) {
  var copy = (array || []).slice();
  copy[index] = value;
  return copy;
};

var FieldArrayInner =
/*#__PURE__*/
function (_super) {
  __extends(FieldArrayInner, _super);

  function FieldArrayInner(props) {
    var _this = _super.call(this, props) || this;

    _this.updateArrayField = function (fn, alterTouched, alterErrors) {
      var _a = _this.props,
          name = _a.name,
          validateOnChange = _a.validateOnChange,
          _b = _a.formik,
          setFormikState = _b.setFormikState,
          validateForm = _b.validateForm;
      setFormikState(function (prevState) {
        var updateErrors = typeof alterErrors === 'function' ? alterErrors : fn;
        var updateTouched = typeof alterTouched === 'function' ? alterTouched : fn;
        return __assign({}, prevState, {
          values: setIn(prevState.values, name, fn(getIn(prevState.values, name))),
          errors: alterErrors ? setIn(prevState.errors, name, updateErrors(getIn(prevState.errors, name))) : prevState.errors,
          touched: alterTouched ? setIn(prevState.touched, name, updateTouched(getIn(prevState.touched, name))) : prevState.touched
        });
      }, function () {
        if (validateOnChange) {
          validateForm();
        }
      });
    };

    _this.push = function (value) {
      return _this.updateArrayField(function (array) {
        return (array || []).concat([cloneDeep(value)]);
      }, false, false);
    };

    _this.handlePush = function (value) {
      return function () {
        return _this.push(value);
      };
    };

    _this.swap = function (indexA, indexB) {
      return _this.updateArrayField(function (array) {
        return swap(array, indexA, indexB);
      }, true, true);
    };

    _this.handleSwap = function (indexA, indexB) {
      return function () {
        return _this.swap(indexA, indexB);
      };
    };

    _this.move = function (from, to) {
      return _this.updateArrayField(function (array) {
        return move(array, from, to);
      }, true, true);
    };

    _this.handleMove = function (from, to) {
      return function () {
        return _this.move(from, to);
      };
    };

    _this.insert = function (index, value) {
      return _this.updateArrayField(function (array) {
        return insert(array, index, value);
      }, function (array) {
        return insert(array, index, null);
      }, function (array) {
        return insert(array, index, null);
      });
    };

    _this.handleInsert = function (index, value) {
      return function () {
        return _this.insert(index, value);
      };
    };

    _this.replace = function (index, value) {
      return _this.updateArrayField(function (array) {
        return replace(array, index, value);
      }, false, false);
    };

    _this.handleReplace = function (index, value) {
      return function () {
        return _this.replace(index, value);
      };
    };

    _this.unshift = function (value) {
      var length = -1;

      _this.updateArrayField(function (array) {
        var arr = array ? [value].concat(array) : [value];

        if (length < 0) {
          length = arr.length;
        }

        return arr;
      }, function (array) {
        var arr = array ? [null].concat(array) : [null];

        if (length < 0) {
          length = arr.length;
        }

        return arr;
      }, function (array) {
        var arr = array ? [null].concat(array) : [null];

        if (length < 0) {
          length = arr.length;
        }

        return arr;
      });

      return length;
    };

    _this.handleUnshift = function (value) {
      return function () {
        return _this.unshift(value);
      };
    };

    _this.handleRemove = function (index) {
      return function () {
        return _this.remove(index);
      };
    };

    _this.handlePop = function () {
      return function () {
        return _this.pop();
      };
    };

    _this.remove = _this.remove.bind(_this);
    _this.pop = _this.pop.bind(_this);
    return _this;
  }

  FieldArrayInner.prototype.remove = function (index) {
    var result;
    this.updateArrayField(function (array) {
      var copy = array ? array.slice() : [];

      if (!result) {
        result = copy[index];
      }

      if (isFunction(copy.splice)) {
        copy.splice(index, 1);
      }

      return copy;
    }, true, true);
    return result;
  };

  FieldArrayInner.prototype.pop = function () {
    var result;
    this.updateArrayField(function (array) {
      var tmp = array;

      if (!result) {
        result = tmp && tmp.pop && tmp.pop();
      }

      return tmp;
    }, true, true);
    return result;
  };

  FieldArrayInner.prototype.render = function () {
    var arrayHelpers = {
      push: this.push,
      pop: this.pop,
      swap: this.swap,
      move: this.move,
      insert: this.insert,
      replace: this.replace,
      unshift: this.unshift,
      remove: this.remove,
      handlePush: this.handlePush,
      handlePop: this.handlePop,
      handleSwap: this.handleSwap,
      handleMove: this.handleMove,
      handleInsert: this.handleInsert,
      handleReplace: this.handleReplace,
      handleUnshift: this.handleUnshift,
      handleRemove: this.handleRemove
    };

    var _a = this.props,
        component = _a.component,
        render = _a.render,
        children = _a.children,
        name = _a.name,
        _b = _a.formik,
        _validate = _b.validate,
        _validationSchema = _b.validationSchema,
        restOfFormik = __rest(_b, ["validate", "validationSchema"]);

    var props = __assign({}, arrayHelpers, {
      form: restOfFormik,
      name: name
    });

    return component ? createElement(component, props) : render ? render(props) : children ? typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? Children.only(children) : null : null;
  };

  FieldArrayInner.defaultProps = {
    validateOnChange: true
  };
  return FieldArrayInner;
}(Component);

var FieldArray =
/*#__PURE__*/
connect(FieldArrayInner);

var ErrorMessageImpl =
/*#__PURE__*/
function (_super) {
  __extends(ErrorMessageImpl, _super);

  function ErrorMessageImpl() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ErrorMessageImpl.prototype.shouldComponentUpdate = function (props) {
    if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {
      return true;
    } else {
      return false;
    }
  };

  ErrorMessageImpl.prototype.render = function () {
    var _a = this.props,
        component = _a.component,
        formik = _a.formik,
        render = _a.render,
        children = _a.children,
        name = _a.name,
        rest = __rest(_a, ["component", "formik", "render", "children", "name"]);

    var touch = getIn(formik.touched, name);
    var error = getIn(formik.errors, name);
    return !!touch && !!error ? render ? isFunction(render) ? render(error) : null : children ? isFunction(children) ? children(error) : null : component ? createElement(component, rest, error) : error : null;
  };

  return ErrorMessageImpl;
}(Component);

var ErrorMessage =
/*#__PURE__*/
connect(ErrorMessageImpl);

export { useFormik, Formik, yupToFormErrors, validateYupSchema, useField, Field, FastField, Form, withFormik, move, swap, insert, replace, FieldArray, getIn, setIn, setNestedObjectValues, isFunction, isObject, isInteger, isString, isNaN$1 as isNaN, isEmptyChildren, isPromise, getActiveElement, makeCancelable, connect, ErrorMessage, FormikProvider, FormikConsumer, useFormikContext };
//# sourceMappingURL=formik.esm.js.map
